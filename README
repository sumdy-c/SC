Документы SC

ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!!

Это библиотека стилизации - НЕ надо добавлять сюда загрузку данных, мутацию объектов, виртуальный DOM и прочее.

ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!! ВНИМАНИЕ!!!





Документы SC


Использовать фунционал SC возможно вызовом класса SC -->

const [ s, sc ] = new SC(?param).use([*inline*], [*css*]);

Принимаемые параметры SC, это два массива -
Первый массив = массив именованных инлайн стилей ( подробнее ниже ), если вы не хотите их использовать, можете указать []
Второй массив = массив, с содержанием .css документов, для включения контроля над CSS в вашем документе. если не хотите использовать, укажите []

Объект настройки, передаётся в конструктор SC ( и может быть пропущен ) конфигурирует SC в зависимости от ваших нужд. Все актуальные параметры настройки будут описаны ниже; 


Настройки библиотеки ->
{
    /*
    *   Вызов SC с этим параметром будет выглядить иначе !!! ->
    *   const s = new SC({ onlyS: true }).use([*inline*], [*css*]);
    */
    onlyS: true, //SC не будет возвращать статику по объекту стилизации. ( Рекомендуется )
    offWarn: true, // выключает все предупреждения
}



███████╗    ████████╗     █████╗     ███╗   ██╗    ██████╗      █████╗     ██████╗     ████████╗
██╔════╝    ╚══██╔══╝    ██╔══██╗    ████╗  ██║    ██╔══██╗    ██╔══██╗    ██╔══██╗    ╚══██╔══╝
███████╗       ██║       ███████║    ██╔██╗ ██║    ██║  ██║    ███████║    ██████╔╝       ██║   
╚════██║       ██║       ██╔══██║    ██║╚██╗██║    ██║  ██║    ██╔══██║    ██╔══██╗       ██║   
███████║       ██║       ██║  ██║    ██║ ╚████║    ██████╔╝    ██║  ██║    ██║  ██║       ██║   
╚══════╝       ╚═╝       ╚═╝  ╚═╝    ╚═╝  ╚═══╝    ╚═════╝     ╚═╝  ╚═╝    ╚═╝  ╚═╝       ╚═╝   
                                                                                                

В стандартном варианте, вы можете достать из new SC, объект s, и передать в него любой селектор, и сразу его стилизовать, все просто

Давайте сначала создадим экземпляр SC -

    const s = new SC({onlyS: true}).use([
        {
            name: test,
            styleCSS: {
                display: block,
            }
        }
    ],[]);

    Пока что мы создали инстанс и передали один контролируемый стиль "test", (о самих стилях ниже), использовать очень просто :)

Пример:

    s($('<div>'), 'test').html('Я блочный элемент').append(parent); // всё, стиль добавлен на страницу с помощью SC
    
    Лучшей практикой будет именование селекторов, хоть это совсем и необязательно.

        const mySelector = $('<div>').html('Я блочный элемент').append(parent);
        s(mySelector, 'test');

Отданная вам функция "s", просто вернёт вам селектор, доступный для работы с jquery, поэтому подход к построению вашего документа
будет прежним

s(mySelector).append(parent);

и еще один важный вопрос связан с таким построением s($('<div>')) // вернёт селектор, но зачем мне s ? Это лишний код!

    да, на самом деле это лишний код, объявлять селекторы таким образом не нужно, используйте просто $('<div>'), но есть важное НО
    
    при создании селектора таким образом s($('<div>')), вы говорите sc, что возможно будете использовать этот элемент с ним позднее. 

    И для этого нового элемента будут установлены все необходимые ему атрибуты и кэш, который далее позволит вам использовать его с SC расширением. ( подробнее о расширении ниже )

    const test1 = $('<div>').append(parent); // стандарное объявление селектора
    const test2 = s($('<div>')).append(parent); // объявление селектора с обёрткой sc

    $(test1).SCadd('!line'); // этот код вызовет ошибку, так как sc ничего не знает о нём!
    $(test2).SCadd('!line'); // s($('<div>')) - а тут мы явно о нём ранее рассказывали, и все пройдет хорошо.

    Но на самом деле, лучше не думать об этом, и использовать то, что вам удобно, а когда вы хотите использовать что-то из sc, обернуть все в 's' функцию

    s(test1).SCadd('!line'); - теперь, все будет хорошо, так как даже заранее не объявленный селектор, может быть добавлен туда когда вы этого пожелаете )



██╗███╗   ██╗██╗      █████╗ ██╗███╗   ██╗
██║████╗  ██║██║     ██╔══██╗██║████╗  ██║
██║██╔██╗ ██║██║     ███████║██║██╔██╗ ██║
██║██║╚██╗██║██║     ██╔══██║██║██║╚██╗██║
██║██║ ╚████║███████╗██║  ██║██║██║ ╚████║
╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
                                          

    Теперь можно остановиться на инлайн стилях, вы могли видеть как мы его объявляем

    const s = new SC({onlyS: true}).use([
        {
            name: test,
            styleCSS: {
                display: block,
            }
        },
        {
            name: test2,
            styleCSS: {
                display: block,
            }
        },
        // можете добавить сколько потребуется)
    ],[]);

    в первом массиве, мы можем найти что-то подобное CSSу, давайте вытащим его и рассмотрим отдельно

    {
        name: test,
        styleCSS: {
            display: block,
        }
    }

тут мы объявили инлайн стиль для SC, и любой пишущий на jquery человек, скажет, что .css({ display: block }) = это короче и лаконичнее. И будет прав! 
Давайте углубимся в этот вопрос.

С первого взгляда, такое объявление стилей кажется перегруженным, выйгрывает только его применение ->

$('<div>').css({ display: block });
    против
s($('<div>'), 'test');

второй код явно короче и самое главное, имеет наименование! Это важный параметр в читаемости кода, это легко доказать, 
давайте сделаем какой-нибудь небольшой приближенный к реальности пример, ведь наврядли у вас будет приложение только с одним селектором

Вот как будет выглядить блок с двумя элементами на чистом jquery =

$('<div>').css({ display: flex, width: 100%, height: 100%, font-size: 15px, flex-direction: column }).append(
    $('<div>').css({ display: flex, width: 100%, height: 50% }),
    $('<div>').css({ display: flex, width: 100%, height: 50% })
);

а вот как на SC =

s($('<div>'), 'modal').append(
    s($('<div>'), 'title'),
    s($('<div>'), 'title'),
);

И мы еще не применяли оптимизации, чтобы сделать два индентичных примера!

Тут сразу видно, что код на sc читается лучше, причем по объявлению названия стиля, сразу понятно что это за блок, и к чему он относится,
и что не менее важно, мы сразу видим, где стиль повторился.

Тут конечно, можно сказать, что зато все эти стили будут занимать большое по размеру пространство выше. Да, будут...
Но в процессе разработки, зачастую вы не будете туда смотреть, а любой современный редактор кода, позволит вам скрыть массив стилей за один клик, и да, конечно можно вынести все в отдельный документ


Давайте взглянем, как один из стилей примера выше будет выглядеть у нас в верстке -

<div style="display: flex; width: 100%; height: 100%; font-size: 15px; flex-direction: column;"></div>

 = это пример созданого элемента на jquery, и тут нет ничего необычного. Все мы видели это много раз

и почти не отличим пример с sc =

<div sc='modal' style="display: flex; width: 100%; height: 100%; font-size: 15px; flex-direction: column;"></div>

Я говорю почти, только потому, что SC заботливо оставила нам подсказку, где мы можем найти этот стиль, я говорю о sc='modal'.
Теперь, если у вас что-то пошло не так, вы всегда сможете найти, где этот элемент находится, и какой точно стиль к нему был применён!)

Немного о безопасности.

SC помимо удобства, был разработан для безопасности стилизации, точнее это была его первоцель. Поэтому, если мы вспомним стили выше, они отработают с предупреждением для нас
( вы можете отключить предупреждения, при инициализации в настройках )

    Пример:
        {
            name: test,
            styleCSS: {
                display: block,
            }
        },
        {
            name: test2,
            styleCSS: {
                display: block,
            }
        }
        
            // [SC] Обнаружено повторение стилей
        
        это позволит нам убрать такую путаницу, ведь нам как правило не нужны одинаковые стили в sc, это не имеет смысла. Мы могли бы использовать только test.

        Хорошо, мы все равно хотим повторяться, давайте сделам иначе

        {
            name: test,
            styleCSS: {
                display: block,
            }
        },
        {
            name: test,
            styleCSS: {
                display: flex,
            }
        }

        Вот, теперь сами стили не повторяются, но мы дублировали имя!

        // [SC] *Ошибка*!!! ( текст в этом случае другой) 

        Да, имена стилей должны быть уникальными как и имена классов. В этом случае sc даже отдаст ошибку, чтобы вы не смогли случайно сломать логику стилизации
        
        Не бойтесь, просто дайте стилю другое название, они все собраны у вас в одном месте, в одном массиве. Да и сам sc укажет повторяющеяся имя в тексте ошибки

        {
            name: test,
            styleCSS: {
                display: block,
            }
        },
        {
            name: test2,
            styleCSS: {
                display: flex,
            }
        }

        Теперь все будет работать правильно и хорошо)

        УДАЛЕНИЕ СТИЛЕЙ

    Для удаление стилей в jquery, мы используем обнужение или удаление атрибута style
    в sc такой же подход, но синтаксис явно короче

    s($('<div>'), '!line') = и всё 
    ( только что мы использовали инструкцию, о которых поговорим ниже )
    стили будут безопастно удалены с селектора.


 ██████╗ ██╗       █████╗  ███████╗ ███████╗ ███████╗ ███████╗
██╔════╝ ██║      ██╔══██╗ ██╔════╝ ██╔════╝ ██╔════╝ ██╔════╝
██║      ██║      ███████║ ███████╗ ███████╗ █████╗   ███████╗
██║      ██║      ██╔══██║ ╚════██║ ╚════██║ ██╔══╝   ╚════██║
╚██████╗ ███████╗ ██║  ██║ ███████║ ███████║ ███████╗ ███████║
 ╚═════╝ ╚══════╝ ╚═╝  ╚═╝ ╚══════╝ ╚══════╝ ╚══════╝ ╚══════


Теперь нам все понятно с инлайн стилями, но как ситуация с классами ? Это интересная тема и для этого, когда вы объявляете sc там есть второй массив, 
Давайте создадим новый экземпляр sc, но перед этим мы представим, что совершенно стандартно добавили test.css файл.

const s = new SC({onlyS: true}).use([], ['test.css']);

Как мы видим, мы добавили ранее созданый нами документ .css во второй массив.

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

**ВАЖНО**
Вы не должны указывать путь, создавать css в опредённом месте или что-то подобное. Просто добавьте .css файл в document так-же как и всегда,
и произведите вызов SC в общем потоке кода. Библиотека сама найдет ваш документ.

**ВАЖНО 2**
Заводить документы с одинаковыми именами в одном index.html, это ошибка. И ошибка это в целом web-разработки, не библиотеки. Не делайте так!
Давайте вашим документам css/js/other осмысленные имена.

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


Использовать это так же просто как и стили из предыдущего блока. 

s($('<div>'), '.test');

Такое написание, добавит класс test из нашего документа css, и на это стоит обратить ВНИМАНИЕ!
Если бы допустим, в css файле который мы передали как зависимость, у нас не было бы класса test, то ваше приложение выдало бы ошибку!
Дело в том, что sc ищет классы только в своих доверенных документах, поэтому если вам нужно добавить класс из другого .css файла, поместите его в массив зависимостей,
так же как мы помещали и первый файл.

Это понятно, давайте посмотрим в верстку, и увидим.... что нашего класса нет ? Хотя все стили которые мы писали применились,
вместо нашего знакомого test, мы видим = .SC_test_7BWdf

Да, это правильное поведение нашего класса, ведь если у нас огромное приложение, каков вариант еще встретить класс test ? Конечно, мы можем создавать классы

вот так ".test__testov__testovich_na_teste-main" = но согласитесь, это довольно неудобно, даже не смотря на то что пример гротесктный.

наш .test - всегда будет лакончичнее и проще выглядить в коде.

Вас уже ужасает, что вы не сможете использовать получение селектора по имени класса ? Еще нет ? Вы не сможете)
Точнее работать так не будет =

$('.test'); // селектор не найден на странице.

но есть и хорошие новости ваш $ заменён вашим s!

то есть, просто используете

s('.test'); // HTMLElement

Не смотря на то что по факту такого селектора на странице вы не найдете, в вашем коде он будет обнаружен и возвращён вам. Дело в том что sc уже знает, что вы хотите
и заранее отметила, что по этому селектору, вам бы хотелось получить те или иные элемент(ы).

А КАК УДАЛИТЬ ?

Как мы помним классы объявленные как sc, осложняют работу с jquery, но давайте пока просто вспомним подход к удалению в jquery

    $('.test').removeClass('.test');

    Это хорошо и лаконочно. Тут мы сразу видим что хотим сделать с селектором, и какой класс попал под нож, а теперь посмотрим, что предлагает sc.

    s('.test', '-test');

    И что за "-" ?

    * * *
        Тут нужно отвлечься и немного поговорить о позиционировании библиотеки.
        SC изначально позиционируется как библиотека для стилизации. НО то что мы добавляем при создании экземпляра класса, это не что более того, как настройки.
        Когда мы говорим s('.test') - мы не ищем селектор сами, мы даже не передали его настоящее имя. Все будет возвращаться из внутренних механизмов sc.
        Проще говоря мы просто отдали команду, некую инструкцию к действию.
    * * *

    И теперь мы понимаем, что "-", это префикс инструкций,
    Сама инструкция звучала бы так =
    "Найти определенный класс по этой инструкции, и удалить его."

    Как вы поняли, есть такой же префикс инструкции "."
    Но он уже отдаст команду на добавление класса

    Чтобы было проще, я вынесу блок со всеми доступными инструкциями отдельно (Блок инструкции следующий)

    Сразу стоит отметить, работу с файлом css в таком случае, она не менятся. Вы можете использовать все те же @key-frames, @media и прочее.
    Все будет отработано и записано

    Единственное исключение, когда вы заведете класс с такмим же названием( в файлах зависимостей ), библиотека вас об этом предупредит и подскажет какой класс вы дублировали.

    Небольшого отступления стоит работа с несколькими классами.
    
    Как вы видели в примере удаления
    s('.test', '-test');
    Мы передали только одну инструкцию. Да и больше мы не можем передать, это не будет работать. Что же делать ?
    Ведь нам допустим нужно еще присвоить класс test2 ?
    
    Забегая вперёд, у нас есть функция дополнения, она выглядит как .SCadd();

    Получается ваш код будет выглядеть так, в этом случае

    s('.test', '-test').SCadd('.test2');

    *Подробнее об "SCadd" в блоке "Active";
    
    

############################################################################################################
############################################################################################################
############################################################################################################    
                                                                                                     
`7MMF'  `7MMF'`7MMF'  `7MMF' .g8"""bgd MMP""MM""YMM `7MM"""Mq.`YMM'    `MM'`7MMF'  ,d8o `7MMF' `7MMF' `7MMF'  `7MMF'`7MMF'  `7MMF'
  MM    ,AMM    MM      MM .dP'     `M P'   MM   `7   MM   `MM. VMA    ,V    MM   6P'     MM     MM     MM    ,AMM    MM    ,AMM  
  MM   ,A'MM    MM      MM dM'       `      MM        MM   ,M9   VMA  ,V     MM  ,9       MM     MM     MM   ,A'MM    MM   ,A'MM  
  MM  AV  MM    MMmmmmmmMM MM               MM        MMmmdM9     VMVMP      MMmd<        MM     MM     MM  AV  MM    MM  AV  MM  
  MM,V'   MM    MM      MM MM.              MM        MM           YMP'      MM  `YM.     MM     MM     MM,V'   MM    MM,V'   MM  
  MMV'    MM    MM      MM `Mb.     ,'      MM        MM           jM'       MM   `Mb     MM     MM     MMV'    MM    MMV'    MM  
.JMML.  .JMML..JMML.  .JMML. `"bmmmd'     .JMML.    .JMML.     69bdP'      .JMML.  `MMa..JMMmmmmmMMmm .JMML.  .JMML..JMML.  .JMML.

ИНСТРУКЦИИ БУДУТ ПОПОЛНЯТСЯ СО ВРЕМЕНЕМ, СЛЕДИТЕ ЗА ОБНОВЛЕНИЕМ ЭТОГО ФАЙЛА!

Добавляет инлайн стиль - "styl(название стиля)"
Удаляет все инлайны с элемента - "!line"

Добавить класс = ".my-class"
Удалить класс = "-my-class"

Отчистить элемент = "*empty"
Удалить элемент = "*remove"

############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################




 █████╗  ██████╗████████╗██╗██╗   ██╗███████╗
██╔══██╗██╔════╝╚══██╔══╝██║██║   ██║██╔════╝
███████║██║        ██║   ██║██║   ██║█████╗  
██╔══██║██║        ██║   ██║╚██╗ ██╔╝██╔══╝  
██║  ██║╚██████╗   ██║   ██║ ╚████╔╝ ███████╗
╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝  ╚═══╝  ╚══════╝
                                             

Самая интересная часть библиотеки. Давайте сразу создавать sc instance

const [s, sc] = new SC().use([{
    {
        name: inTest,
        styleCSS: {
            display: 'block'
        }
    }
}], ['text.css']);

const parent = $('<div>');
const child1 = $('<div>');
const child2 = s($('<div>'), '.del_class');

s(parent, 'inTest').append(
    s(child1, '.child_one'),
    s(child2, '.child_two')
)

Мы написали небольшую, ничем не выделяющуюся структуру, теперь мы будем вкючать воображение


    ####
    SCadd
    ####

    Мы уже знаем о такой функции как SCadd, давайте рассмотрим её подробнее.
    Представим, что нам нужно после добавления .child_two, нужно отчистить .del_class, который мы установили ранее

    И мы уже знаем, что нам нужно сделать 
    ...
    s(child2, '.child_two').SCadd('-del_class')
    ...

    Все будет хорошо работать, но что это за SCadd ? Это просто метод добавления инструкции. Он бы придуман, чтобы мы с вами не писали что-то такое)

    
    s(child2, ['.child_two', '-del_class']);

    Такой код был введён в первой реализации библиотеки, и он показал тебя крайне плохо. Не смотря на то что это может показаться удобным, на практике это негативно влияет на
    читаемость такого кода, и все это превращается в монолит, который сложно осознать в целом, или сразу разглядеть логику выполнения инструкций.
    
    Вы можете использовать такого рода инструкции в вашем приложении, но это крайне !НЕ рекомендуется!

    Эту ситуацию исправило включение в sc - SCadd, с этим методом, мы четко видим иерархичность выполнения инструкций, к слову, вам никто не мешает не использовать первую инструкцию
    это даже может улучшить ваше восприятие от кода!

    s(child2).SCadd('.child_two').SCadd('-del_class');

    Тут мы можем сразу увидеть добавление инструкции, без вглядывания в селектор.

    По причинам которые уже были озвучины, SCadd поддерживает строго одну инструкцию!

    Так же напомню, что методы, дополняют jquery, а не заменяют его, поэтому если мы помним что объявили child2, сразу обернув в s, мы можем делать и так
    
    $(child2).SCadd('.child_two').SCadd('-del_class');

    это не Рекомендуется, но позволяется.


    ###
    SCmove
    ###

    ( ПРИМЕР ниже УСТАРЕЛ при обновлении, теперь используется передача функции для первой модификации. Он оставлен, чтобы не удалять объяснение SCmove )

    Теперь самая запутанная и сложная часть SC, (на самом деле, совершенно не сложная).

    Давайте сразу представим ситуацию, и немного модифицируем наш код

        s(parent, 'inTest').append(
            s(child1, '.child_one').html(title),
            s(child2, '.child_two')
        )
    
    тут мы добавили в child1 некий title, а теперь пусть этот title будет приходить с сервера, а нашем случае для понимание завернем по нему setTimeout

    let title; // undefined

    setTimeout(() => {
        title = "Я Заголовок!"
    }, 2000);

    Как нам поступить, если нужно добавить класс после добавления заголовка ?

    Это решается по разному, но верятно разработчик решали бы это проблему, следующим путём
    
    let title; // undefined

    setTimeout(() => {
        title = "Я Заголовок!"
        s('.child1').SCadd('.view_class');
    }, 2000);

    s(parent, 'inTest').append(
        s(child1, '.child_one').html(title),
        s(child2, '.child_two')
    )

    Этот код решает задачу, но могут быть разные варианты, которые на него повлияют, к примеру, мы можем не знать когда придут данные, и селектора '.child1' еще может не быть на странице
    Код который определят загрузку заголовка может быть оторван от отображения, что затруднит такую реализацию и зачастую сделает её невозможной
    Нам может не дойти наш title, что требует написание лишних проверок.
    И еще много чего, на самом деле даже в таком простейшем примере, мы уже нашли столько возможных проблем, а еще бывают случаи когда надо поменять ряд селекторов.
    Тогда нужно будет еще создавать и массив, в который их нужно поместить. В целом, вы поняли, это стандартные проблемы которые мы успешно решаем каждый день
    А решает ли их разработчик с sc ? Вот как бы поступил он

    const title = { value: undefined }; // Обратите внимание, что мы явно указали что title = undefined, тут это требование, которое играет на руку читаемости + const вместо let

    setTimeout(() => {
        title.value.value = "Я Заголовок!"
    }, 2000);

    s(parent, 'inTest').append(
        s(child1, '.child_one').SCmove(title, '.view_class').html(title.value.value),
        s(child2, '.child_two')
    );

    Что тут происходит ?
    
    Самое простое объясение - безопасная мутация компонента.

    Давайте разбираться...

    Мы создали объект, у которого есть value
    мы поместили этот объект в SCmove, и дописали имя класса который нам нужен вторым параметором.
    Мы поменяли не title.value; Мы изменили title.value.value;

    Что это значит
    Проще говоря, мы создали состояние, и это в данном примере наш title. Состояние может быть только объектом, с value, поэтому, мы создаём его таким образом
    Далее, мы прикрепили это состояние к селектору, что явно дало понять, что за этим селектором следят

    Далее произойдет следующее. Как только title.value.value, станет "Я Заголовок!", к элементу будет применён стиль. И всё) Пока  title.value.value не поменять, мы можем
    быть спокойны, ничего не произойдет, изменения будут только тогда, когда title будет поменян. И это в абсолютно любой момент.

    Так же мы можем спокойно получать состояние у title.value.value. Оно не пропадёт и не поменяется.

    а что если ?...

     setTimeout(() => {
        title.value.value = "Я Заголовок!"
    }, 2000);

    s(parent, 'inTest').append(
        s(child1, '.child_one').SCmove(title, '.view_class').html(title.value.value),
        s(child2, '.child_two').SCmove(title, '.view_class2')
    );

    мы добавили к child2 .SCmove(title, '.view_class2'), ответ будет кратким. Все сработает нормально, состояние привязано к сущности селектора, которая собирается специальными 
    объектами, поэтому он может содержать неограниченое количество состояний и мутаций классов
    

    #####
    SCmove (mod)
    #####

    SC поддерживает более глубокую настройку инструкций. Для этого нужно передать переменной состояния инструкции для применения.
    Сразу рассмотрим на примере

    
    const title = { value: undefined };

    setTimeout(() => {
        title.value.value = ".view_class";
    }, 2000);

    setTimeout(() => {
        title.value.value = ".view_class2";
    }, 4000);

    s(parent, 'inTest').append(
        s(child1, '.child_one').SCmove(title).html("Я Заголовок!"),
        s(child2, '.child_two').SCmove(title)
    );

    В этом примере, title будет контролировать 2 селектора, и поменяет стили как только они будут присвоены переменной состояния.
    Обратите внимание, что использование SCmove в такой модификации поддерживает передачу инструкций в массиве,
    что в отличии от функции стилизации "s", уже будет хорошим подходом!

    title.value.value = ["-view_class", ".view_class2"];

    Обратите вниание:
    - SCmove БУДЕТ вызван при присовоении, если вы передали в него первоначальные инструкции (значения)
    - SCmove гарантированно отработает после регистрации при изменении состояния, если SCmove получит новое значение.
    - SCmove имеет 3-й параметр, ( по умолчанию false). Если истина, то SC не будет смотреть на повторение значения и отработает при нём


░██████╗░█████╗░  ██████╗░██╗░░░██╗██╗░░░░░███████╗░██████╗
██╔════╝██╔══██╗  ██╔══██╗██║░░░██║██║░░░░░██╔════╝██╔════╝
╚█████╗░██║░░╚═╝  ██████╔╝██║░░░██║██║░░░░░█████╗░░╚█████╗░
░╚═══██╗██║░░██╗  ██╔══██╗██║░░░██║██║░░░░░██╔══╝░░░╚═══██╗
██████╔╝╚█████╔╝  ██║░░██║╚██████╔╝███████╗███████╗██████╔╝
╚═════╝░░╚════╝░  ╚═╝░░╚═╝░╚═════╝░╚══════╝╚══════╝╚═════╝░


Добавлена воможность написать правило изменения. Это изменение больше коснулось документов .css, и используется очень простыми способами

В начало css документа добавьте стуктуру:

SC_rules {
    --rule: {

    };
}

...это определит для SC, что в данном документе есть определенные правила, за которыми он должен следить.

Далее по мере добавления в ваш документ .css классов, мы можете определить, по какому правилу их следует изменить, и какие конктретно:

SC_rules {
    --rule: {
        thex = .main[
            background-color: #dd763a,
            width: 400px
        ],
        
        test = .main[
            background-color: #bebebe,
            border-radius: 10px,
            width: 550px
        ],

        go = .new_btn[
            background-color: #4cb422
        ],

        new_rules = .new_btn[ 
            justify-content: center, 
            height: 35px,
            user-select: auto
        ]
    };
}

Обратите ВНИМАНИЕ на несколько моментов связанных с применением этого .

    ℍ𝕖 𝕪би𝕡𝕒йт𝕖 --𝕣𝕦𝕝𝕖
=====================
--rule, хоть и позволяет себя переопределить, и все будет работать ( то есть вместо него можно написать хоть --joke ), делать этого не нужно
В ходе развития SC, данное ключевое слово будет использовано для выборки нужного функционала, поэтому его написание таким образом - поможет сохранять
обратную совместимость и корректную работу

    чт𝕠 𝕜 ч𝕖𝕄𝕪 ❔
=====================
Если посмотреть на структуру объявления правила, можно легко понять что к чему относится, но лучше проговорить это

thex = .main[
            background-color: #dd763a,
            width: 400px
        ],

"thex" - как раз то самое правило, по которому вы будете обращатся к выполнению

... и рядом  находиться всем привычный css класс, с одним лишь отличием в скобках.

.main   [
            background-color: #dd763a,
            width: 400px
        ] 

    𝔼щ𝕖 чт𝕠 т𝕠 ❔
=====================
Важно помнить лишь несколько правил
- SC_rules - работает только с классами, так как id и селекторы не создают таблицы, а стилизируются иными способами.
- SC_rules работает с одиним классом, за раз, что в дальнейшем возможно будет пересмотрено и будет организовано закрепление
множества классов за правилом. Пока что, SC предлагает вызывать "Каскад правил", о чем будет рассказано далее...

ВАЖНО

ЗАПЯТАЯ В КОНЦЕ ПРАВИЛ, вызовет проблемы с парсингом. Следите за синтаксисисом

Правила созданы, что дальше ?

А дальше, их просто можно вызвать, в целом двумя способами 

cosnt [S, SC] = new SC().use([...], [...]);

1) SC.rules('thex');
    или 
2) S('*rules').rules('thex');

на ваш выбор, что будет удобнее, а если отдельно поговорить о .rules( ... ), то он принимает 2 агрумента.
1 - правило, или массив правил, которые нужно выполнить
2 (необяз), - boolean ( по умолчанию true ), стоит ли мутировать класс. Если false, к элементам будет добавлен inline стиль, если true = будет изменен сам класс


    #########################################################################################################################################
    #########################################################################################################################################
    #########################################################################################################################################
    #########################################################################################################################################
    #########################################################################################################################################

( UPDATE )
    - первая модификация SCmove потерпит изменения:
        
            Старая релизация  будет удалена!! Обратной совместимости не будет только с ПЕРВОЙ модификацией SCmove()
            Теперь принимает функцию, которая принимает значение и возвращает стили.

        Пример:
            let val = { value: null };

            S(selector).SCmove(val, (e) => {
                if(e === 1) {
                    return '.class_one';
                }
                
                if(e === 2) {
                    return '.class_two';
                }
            }).append(wrapper);
        
            //Для этих целей, лучше использовать SCS = (
                const value = new SCS();
                value.set(1);
            )

            val.value.value = 1;

            // S(selector) - будет добавлен класс .class_one

            Такая конструкция позволяет гибко назначить какие значения, каким стилям будут принадлежать.
            
            Поддержка: { SCclass, SCinline }


    - Обновлен алгоритм построения таблицы стилей SC, теперь записывает все классы SC в одну подтаблицу, что экономит ресурсы браузера.
    - Обновлено определение при обработке типа SCmove, поправлена ошибка при использовании разных переключателей
    - Теперь синтаксис "val.value.value = N" может вызвать проблемы с построением дерева состояний

######################################################################################################################

SC_stable - из-за применения в ЛХ, выпущена версия для стабильного использования.
    ( при разработке на стабильной версии, не прокидывайте один css файл, в разные классы SC. );